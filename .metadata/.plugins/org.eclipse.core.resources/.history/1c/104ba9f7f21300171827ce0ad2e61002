package harrypotter.model.tournament;

import harrypotter.model.character.Champion;
import harrypotter.model.character.HufflepuffWizard;
import harrypotter.model.character.Wizard;
import harrypotter.model.magic.Potion;
import harrypotter.model.world.ChampionCell;
import harrypotter.model.world.CollectibleCell;
import harrypotter.model.world.Direction;
import harrypotter.model.world.EmptyCell;

import java.awt.Point;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;


public class FirstTask extends Task {
	private Random randomGenerator;
	
	//An array list of Points containing the cells marked by the dragon to attack once the currentChamp makes his move.
	private ArrayList<Point> markedCells;
	
	//An array list containing the winners of this task who are thus qualified for the second task.
	private ArrayList<Champion> winners;
	
	public FirstTask(ArrayList<Champion> champions) throws IOException{
		super(shuffleHelper(champions));
		markedCells = new ArrayList<Point>();
		markCells();
		winners = new ArrayList<Champion>();
		
		
	}
	
	//helper that shuffles the champions.
	private static ArrayList<Champion> shuffleHelper(ArrayList<Champion> champions){
		Collections.shuffle(champions);
		return champions;
	}
	
	public void generateMap(){
		super.addplayers();
		super.task1();
				
	}
	
	public ArrayList<Point> getMarkedCells(){
		return this.markedCells;
	}
	
	public void setMarkedCells(ArrayList<Point> markedCells){
		this.markedCells=markedCells;
	}
	public ArrayList<Champion> getWinners(){
		return this.winners;
	}
	
	public void setWinners(ArrayList<Champion> winners){
		this.winners=winners;
	}
	
	//This method is responsible for getting the cells that a dragon will attack after the currentChamp performs an action.
	public void markCells(){
		randomGenerator = new Random();

		// get location of champ
		Point p= new Point(((Wizard)getCurrentChamp()).getLocation());
		int x = p.x;
		int y=p.y;
		
		//flags to prevent duplicates 
		boolean f0=true;
		boolean f1=true;
		boolean f2=true;
		boolean f3=true;
		boolean f4=true;
		
		// set 2 locations.
		for(int i=0;i<2;i++){
			int xx=randomGenerator.nextInt(5);
			switch (xx){
			// fire in same cell
			case 0:if(f0){ 
						markedCells.add(p);f0=false; break;}
					else{ i--; break;}
			// fire left
			case 1: if (x>0&& f1){
						Point p1= new Point(p); p1.translate(-1,0); markedCells.add(new Point(x-1, y));f1=false; break;}
					else{ i--; break;}
			//fire right
			case 2: if (x<9&& f2){
						Point p2= new Point(p); p2.translate(1,0); markedCells.add(new Point(x+1, y));f2=false; break;}
					else{ i--; break;}
			//fire up
			case 3: if (y<9&& f3){
					Point p3= new Point(p); p3.translate(0,1); markedCells.add(new Point(x, y+1));f3=false; break;}
				else{ i--; break;}
			//fire down
			case 4: if (y<0&& f4){
					Point p4= new Point(p); p4.translate(0,-1); markedCells.add(new Point(x, y-1));f4=false; break;}
				else{ i--; break;}
			default: break;
			}
			
		}
		
		
		/*Point p =new Point(((Wizard)this.getCurrentChamp()).getLocation());
		markedCells.add(p);
		markedCells.add(getTargetPoint(Direction.FORWARD));
		markedCells.add(getTargetPoint(Direction.BACKWARD));
		markedCells.add(getTargetPoint(Direction.RIGHT));
		markedCells.add(getTargetPoint(Direction.LEFT));
		Collections.shuffle(markedCells);
		markedCells.remove(4);
		markedCells.remove(3);
		markedCells.remove(2);*/
	}
	
	//the dragon fires on the markedCells.
	public void fire() throws IOException{
		// looping on the fire cells
		for (int i=0; i<markedCells.size();i++){
			Point p= markedCells.get(i);
			// looping on available champs
			for(int j=0; j<getChampions().size();j++){
				// checking if there is a champ in the cell
				if (((Wizard)getChampions().get(j)).getLocation().x==p.x&& ((Wizard)getChampions().get(j)).getLocation().y==p.y){
					if(((Wizard)getChampions().get(j)).getHp()-150>0)
					((Wizard)getChampions().get(j)).setHp((((Wizard)getChampions().get(j)).getHp())-150);
					// removing champs with hp<=0
					else{
						((Wizard)getChampions().get(j)).setHp(0);
						int x = (int) ((Wizard)getChampions().get(j)).getLocation().getX();
						int y = (int) ((Wizard)getChampions().get(j)).getLocation().getY();
						getMap()[x][y]= new EmptyCell();
						getChampions().remove(j);
						j--;
						if (!getChampions().contains(getCurrentChamp()))
							setCurrentChamp(getChampions().get(0));
						if(getChampions().isEmpty())
						{ 	if (getListener() != null){
									getListener().onFinishingFirstTask(((FirstTask) this).getWinners());
							}
						}
					}
				}
			}
		}
		getMarkedCells().clear();
	}
	
	
	//moving the currentChamp one cell up
	public void moveForward() throws IOException {
		//getting old point
		Point pp= ((Wizard)getCurrentChamp()).getLocation();
		Point p=new Point(pp);
		// moving it up
		p.translate(-1, 0);
		//checking if it is possible to move
		if (getMap()[p.x][p.y] instanceof EmptyCell || getMap()[p.x][p.y] instanceof CollectibleCell){
			//changing ip after collecting the collectible
			if (getMap()[p.x][p.y] instanceof CollectibleCell){
				int amount =((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()).getAmount();
				int newIp= amount + ((Wizard)getCurrentChamp()).getIp();
				((Wizard)getCurrentChamp()).setIp(newIp);
				((Wizard)getCurrentChamp()).getInventory().add(((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()));
			}
			//changing map cell type
			Point oldP= ((Wizard)getCurrentChamp()).getLocation();
			getMap()[oldP.x][oldP.y]= new EmptyCell();
			getMap()[p.x][p.y]= new ChampionCell(getCurrentChamp());
			//changing champs location
			((Wizard)getCurrentChamp()).setLocation(p);
		}
		finalizeAction();
	}
	
	//moving the currentChamp one cell down
	public void moveBackward() throws IOException {
		Point pp= ((Wizard)getCurrentChamp()).getLocation();
		Point p=new Point(pp);
		p.translate(1, 0);
		if (getMap()[p.x][p.y] instanceof EmptyCell || getMap()[p.x][p.y] instanceof CollectibleCell){
			if (getMap()[p.x][p.y] instanceof CollectibleCell){
				int amount =((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()).getAmount();
				int newIp= amount + ((Wizard)getCurrentChamp()).getIp();
				((Wizard)getCurrentChamp()).setIp(newIp);
				((Wizard)getCurrentChamp()).getInventory().add(((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()));
			}
			Point oldP= ((Wizard)getCurrentChamp()).getLocation();
			getMap()[oldP.x][oldP.y]= new EmptyCell();
			getMap()[p.x][p.y]= new ChampionCell(getCurrentChamp());
			((Wizard)getCurrentChamp()).setLocation(p);
		}
		finalizeAction();
	}
	
	//moving the currentChamp one cell left
	public void moveLeft() throws IOException {
		Point pp= ((Wizard)getCurrentChamp()).getLocation();
		Point p=new Point(pp);
		p.translate(0, -1);
		if (getMap()[p.x][p.y] instanceof EmptyCell || getMap()[p.x][p.y] instanceof CollectibleCell){
			if (getMap()[p.x][p.y] instanceof CollectibleCell){
				int amount =((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()).getAmount();
				int newIp= amount + ((Wizard)getCurrentChamp()).getIp();
				((Wizard)getCurrentChamp()).setIp(newIp);
				((Wizard)getCurrentChamp()).getInventory().add(((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()));
			}
			Point oldP= ((Wizard)getCurrentChamp()).getLocation();
			getMap()[oldP.x][oldP.y]= new EmptyCell();
			getMap()[p.x][p.y]= new ChampionCell(getCurrentChamp());
			((Wizard)getCurrentChamp()).setLocation(p);
		}
		finalizeAction();
	}
	
	//moving the currentChamp one cell right
	public void moveRight() throws IOException {
		Point pp= ((Wizard)getCurrentChamp()).getLocation();
		Point p=new Point(pp);
		p.translate(0, 1);
		if (getMap()[p.x][p.y] instanceof EmptyCell || getMap()[p.x][p.y] instanceof CollectibleCell){
			if (getMap()[p.x][p.y] instanceof CollectibleCell){
				int amount =((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()).getAmount();
				int newIp= amount + ((Wizard)getCurrentChamp()).getIp();
				((Wizard)getCurrentChamp()).setIp(newIp);
				((Wizard)getCurrentChamp()).getInventory().add(((Potion)((CollectibleCell)getMap()[p.x][p.y]).getCollectible()));
			}
			Point oldP= ((Wizard)getCurrentChamp()).getLocation();
			getMap()[oldP.x][oldP.y]= new EmptyCell();
			getMap()[p.x][p.y]= new ChampionCell(getCurrentChamp());
			((Wizard)getCurrentChamp()).setLocation(p);
		}
		finalizeAction();
	}
	
	public void onSlytherinTrait(Direction d) throws IOException {
		super.onSlytherinTrait(d);
		((Wizard)getCurrentChamp()).setTraitCooldown(6);
		finalizeAction();
	}
	
	public Object onRavenclawTrait(){
		if (!isTraitActivated()){
			((Wizard)getCurrentChamp()).setTraitCooldown(5);
			setTaitActivated(true);
		}
		return markedCells;
	}
	/*public void finalizeAction() throws IOException{
		super.finalizeAction();
		Point p =((Wizard)getCurrentChamp()).getLocation();

			if(!((Wizard)getCurrentChamp() instanceof HufflepuffWizard) &&isTraitActivated())
			{
				fire();
			}
			if (getAllowedMoves()==0)
				endTurn();
			
		if (p.x==4&& p.y==4){
			winners.add(getCurrentChamp());
			getMap()[4][4]= new EmptyCell();
			getChampions().remove(getCurrentChamp());
			
		if(getChampions().isEmpty()|| getWinners().size()==4)
		{
			if (getListener() != null)
				getListener().onFinishingFirstTask(winners);
		}
		}
		
	}*/

}
